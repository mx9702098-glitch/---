# 产品需求文档：村庄表格管理系统（基于当前实现版本）

---

# 一、需求背景（需求的价值和目的）

### 需求背景 & 需求来源（要做什么）

基于当前已实现的村庄表格管理系统，该系统已经具备以下核心功能：
- 智能表格数据采集和识别
- 村民信息结构化存储和管理
- 历史表格数据查询和统计
- 数据同步状态管理
- 图文校对和确认功能

### 需求目标用户，以及用户特点（为谁做）

**主要用户：**
- 村委会工作人员（村干部、文书等）- 数据录入和管理
- 村民小组长 - 数据采集和上报
- 数据统计人员 - 数据分析和报表生成

**用户特点：**
- 年龄跨度大（30-60岁为主），技术接受度差异大
- 对数据准确性要求高，容错率低
- 需要离线工作能力（农村网络不稳定）
- 对响应速度敏感（不能等待过长时间）

### 需求出发点，以及能够解决的问题（为什么做）

**核心价值：**
1. **提升数据录入效率**：通过智能识别技术，将纸质表格转化为结构化数据
2. **保障数据完整性**：支持离线操作，网络恢复后自动同步
3. **实现数据可追溯**：记录完整的数据变更历史
4. **提供数据分析能力**：结构化存储后可进行统计分析

---

# 二、需求描述（详细业务逻辑描述）

## 2.1 系统架构设计（基于当前实现）

### 2.1.1 技术架构

```
┌─────────────────────────────────────────────────────────┐
│                    前端层（Web应用）                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │ 首页     │  │ 智能采集 │  │ 历史表格 │  │ 识别结果 │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
└─────────────────────────────────────────────────────────┘
                          ↕ (本地存储)
┌─────────────────────────────────────────────────────────┐
│                    业务逻辑层（JavaScript）                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │ 任务管理 │  │ 数据识别 │  │ 数据同步 │  │ 统计分析 │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
└─────────────────────────────────────────────────────────┘
                          ↕
┌─────────────────────────────────────────────────────────┐
│                    数据存储层                             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │ localStorage │  │ 模拟数据 │  │ 缓存数据 │  │ 埋点数据 │ │
│  │ (本地存储) │  │ (演示)   │  │ (临时)   │  │ (分析)   │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 2.1.2 核心模块划分（基于当前实现）

1. **任务管理模块**
   - 任务创建、查询、更新、删除（CRUD）
   - 任务状态管理（已同步/未同步）
   - 任务列表展示和筛选

2. **数据识别模块**
   - 表格数据智能识别
   - 村民信息结构化处理
   - 数据质量分析和校验

3. **数据同步模块**
   - 本地数据缓存管理
   - 同步状态跟踪
   - 离线数据管理

4. **统计分析模块**
   - 数据完整性统计
   - 重复数据检测
   - 数据质量评估

## 2.2 功能模块详细说明（基于当前实现）

### 2.2.1 首页模块

**功能职责：**
- 系统入口和导航
- 功能模块快速访问
- 用户引导和帮助

**核心逻辑：**

1. **页面导航流程**
```
用户打开应用
  ↓
显示首页（包含智能采集和历史表格入口）
  ↓
用户选择功能模块
  ├─ 智能采集 → 进入智能采集页面
  └─ 历史表格 → 进入历史表格管理页面
```

2. **页面切换逻辑**
```javascript
// 页面切换函数
function goToSmartCollection() {
    // 记录埋点事件
    trackEvent({ event_name: 'enter_smart_collection' });
    
    // 页面切换动画
    document.getElementById('homePage').classList.add('hidden');
    document.getElementById('smartCollectionPage').classList.remove('hidden');
    
    // 初始化任务列表
    renderTaskList();
}

function goToHome() {
    document.getElementById('smartCollectionPage').classList.add('hidden');
    document.getElementById('homePage').classList.remove('hidden');
}
```

### 2.2.2 历史表格管理模块

**功能职责：**
- 表格任务的展示和管理
- 任务状态跟踪（已同步/未同步）
- 任务详情查看
- 数据统计和分析

**核心逻辑：**

1. **任务状态管理**
```
任务状态：
- 已同步（synced）：数据已成功同步到服务器
- 未同步（unsynced）：数据仅保存在本地，需要同步

状态转换规则：
- 未同步 → 已同步：用户手动同步或自动同步成功
- 已同步 → 未同步：本地数据被修改，需要重新同步
```

2. **任务列表渲染**
```javascript
// 任务列表渲染函数
function renderTaskList() {
    const taskList = document.getElementById('taskList');
    taskList.innerHTML = '';
    
    tasks.forEach(task => {
        const taskElement = createTaskElement(task);
        taskList.appendChild(taskElement);
    });
}

// 创建任务卡片元素
function createTaskElement(task) {
    const div = document.createElement('div');
    div.className = `task-card ${task.status === 'synced' ? 'synced' : 'unsynced'}`;
    
    div.innerHTML = `
        <div class="task-header">
            <h3>${task.title}</h3>
            <span class="status-badge ${task.status}">${task.status === 'synced' ? '已同步' : '未同步'}</span>
        </div>
        <div class="task-info">
            <span>创建时间：${task.createDate}</span>
            <span>创建人：${task.creator}</span>
        </div>
        <div class="task-stats">
            <span>数据条数：${task.ocrData.length}</span>
        </div>
    `;
    
    return div;
}
```

## 2.3 核心业务流程（基于当前实现）

### 流程1：智能采集流程

```
[前端] 用户点击"智能采集"按钮
  ↓
[前端] 进入智能采集页面
  ↓
[前端] 显示采集界面（包含图片上传区域）
  ↓
[前端] 用户上传表格图片
  │   - 支持拖拽上传
  │   - 支持点击选择文件
  │   - 支持多文件上传
  ↓
[前端] 图片预处理
  │   - 图片格式验证
  │   - 图片大小检查
  │   - 生成预览图
  ↓
[前端] 调用智能识别服务
  │   - 发送图片到识别接口
  │   - 显示识别进度
  │   - 处理识别结果
  ↓
[前端] 显示识别结果
  │   - 表格数据预览
  │   - 识别置信度显示
  │   - 可编辑的表格界面
  ↓
[前端] 用户确认数据
  │   - 数据校验和修正
  │   - 必填字段检查
  │   - 数据格式验证
  ↓
[前端] 保存采集结果
  │   - 生成任务ID
  │   - 保存到本地存储
  │   - 标记为未同步状态
  ↓
[前端] 显示成功提示
  ↓
[前端] 返回任务列表
  ↓
结束
```

### 流程2：历史表格管理流程

```
[前端] 用户点击"历史表格"按钮
  ↓
[前端] 进入历史表格管理页面
  ↓
[前端] 加载任务列表
  │   - 从本地存储读取数据
  │   - 按时间倒序排列
  │   - 显示同步状态标识
  ↓
[前端] 渲染任务卡片
  │   - 任务标题
  │   - 创建时间
  │   - 创建人
  │   - 数据条数
  │   - 同步状态
  ↓
用户选择操作：
  ├─ 操作1：查看任务详情
  │   ↓
  │  [前端] 显示任务详情页面
  │   │   - 表格数据展示
  │   │   - 数据统计信息
  │   │   - 操作按钮
  │   ↓
  │  [前端] 用户查看数据
  │   ↓
  │  [前端] 返回任务列表
  │
  ├─ 操作2：同步数据
  │   ↓
  │  [前端] 检查网络状态
  │   ↓
  │  [前端] 发送同步请求
  │   ↓
  │  [后端] 处理同步请求
  │   ↓
  │  [前端] 更新同步状态
  │   ↓
  │  [前端] 刷新任务列表
  │
  └─ 操作3：删除任务
      ↓
     [前端] 显示删除确认对话框
      ↓
     [前端] 用户确认删除
      ↓
     [前端] 删除本地数据
      ↓
     [前端] 刷新任务列表
  ↓
结束
```

### 流程2：查看和编辑任务详情

```
[前端] 用户点击任务卡片
  ↓
[前端] 检查本地缓存
  │   - 如有缓存，先显示缓存数据
  │   - 同时发起网络请求更新
  ↓
[前端] 请求任务详情
  ↓
[后端] 查询任务信息
  │   - 从数据库读取任务基本信息
  │   - 读取OCR识别数据
  │   - 读取操作历史记录
  ↓
[后端] 权限验证
  │   - 检查用户是否有查看权限
  │   - 检查数据隔离规则
  ↓
[后端] 返回任务详情
  ↓
[前端] 渲染任务详情
  │   - 显示任务元信息
  │   - 渲染表格数据
  │   - 显示操作按钮
  ↓
用户选择操作：
  ├─ 操作1：修改识别结果
  │   ↓
  │  [前端] 进入编辑模式
  │   │   - 表格单元格变为可编辑
  │   │   - 显示保存/取消按钮
  │   ↓
  │  [前端] 用户修改数据
  │   │   - 实时验证数据格式
  │   │   - 标记已修改的单元格
  │   ↓
  │  [前端] 用户点击保存
  │   ↓
  │  [前端] 数据验证
  │   │   - 必填字段检查
  │   │   - 数据类型检查
  │   │   - 数据范围检查
  │   ↓
  │  [前端] 生成变更记录
  │   │   - 记录修改前的值
  │   │   - 记录修改后的值
  │   │   - 记录修改时间和操作人
  │   ↓
  │  [前端] 提交修改请求
  │   ↓
  │  [后端] 权限验证
  │   │   - 检查用户是否有编辑权限
  │   ↓
  │  [后端] 数据校验
  │   │   - 重复前端验证逻辑
  │   │   - 业务规则校验
  │   ↓
  │  [后端] 保存修改
  │   │   - 更新任务数据
  │   │   - 保存变更历史
  │   │   - 更新修改时间
  │   ↓
  │  [后端] 触发同步
  │   │   - 通知其他在线用户
  │   │   - 更新缓存
  │   ↓
  │  [前端] 更新本地数据
  │   │   - 更新IndexedDB
  │   │   - 刷新界面
  │   ↓
  │  [前端] 显示保存成功提示
  │
  ├─ 操作2：删除任务
  │   ↓
  │  [前端] 显示删除确认对话框
  │   │   - 提示：删除后无法恢复
  │   │   - 显示任务标题
  │   ↓
  │  [前端] 用户确认删除
  │   ↓
  │  [前端] 提交删除请求
  │   ↓
  │  [后端] 权限验证
  │   │   - 检查用户是否有删除权限
  │   │   - 检查任务状态（已完成的任务不能删除）
  │   ↓
  │  [后端] 软删除任务
  │   │   - 标记 deleted = true
  │   │   - 保留数据（用于审计）
  │   │   - 记录删除时间和操作人
  │   ↓
  │  [后端] 返回删除成功
  │   ↓
  │  [前端] 更新本地数据
  │   │   - 从列表中移除
  │   │   - 更新IndexedDB
  │   ↓
  │  [前端] 关闭详情页
  │   ↓
  │  [前端] 刷新任务列表
  │   ↓
  │  [前端] 显示删除成功提示
  │
  └─ 操作3：关闭详情
      ↓
     [前端] 关闭详情页
      ↓
     返回任务列表
  ↓
结束
```

### 流程3：数据同步流程

```
[触发条件]
  - 用户创建/修改/删除任务
  - 网络从离线恢复在线
  - 定时同步（每5分钟）
  - 用户手动触发同步
  ↓
[前端] 检查网络状态
  │   - 如果离线，加入同步队列，等待网络恢复
  │   - 如果在线，继续执行
  ↓
[前端] 获取待同步数据
  │   - 从IndexedDB读取 sync_status = 'pending' 的记录
  │   - 按时间戳排序
  ↓
[前端] 批量同步
  │   - 每批最多50条记录
  │   - 使用事务保证原子性
  ↓
[前端] 发送同步请求
  │   - 请求体包含：
  │     * 操作类型（create/update/delete）
  │     * 数据内容
  │     * 本地时间戳
  │     * 客户端ID
  ↓
[后端] 接收同步请求
  ↓
[后端] 冲突检测
  │   - 比较服务器时间戳和客户端时间戳
  │   - 检查数据版本号
  │   ↓
  │  是否有冲突？
  │   ├─ 无冲突
  │   │   ↓
  │   │  直接应用变更
  │   │   ↓
  │   │  更新数据库
  │   │   ↓
  │   │  返回成功
  │   │
  │   └─ 有冲突
  │       ↓
  │      应用冲突解决策略
  │       │
  │       ├─ 策略1：服务器优先（默认）
  │       │   - 忽略客户端变更
  │       │   - 返回服务器最新数据
  │       │
  │       ├─ 策略2：客户端优先
  │       │   - 覆盖服务器数据
  │       │   - 记录冲突日志
  │       │
  │       └─ 策略3：手动合并
  │           - 返回冲突标记
  │           - 提示用户选择
  │       ↓
  │      返回冲突信息
  ↓
[前端] 处理同步结果
  │   ├─ 成功
  │   │   ↓
  │   │  更新 sync_status = 'synced'
  │   │   ↓
  │   │  更新本地时间戳
  │   │   ↓
  │   │  从同步队列移除
  │   │
  │   └─ 失败/冲突
  │       ↓
  │      重试策略
  │       │   - 第1次失败：立即重试
  │       │   - 第2次失败：5秒后重试
  │       │   - 第3次失败：30秒后重试
  │       │   - 第4次失败：标记为冲突，提示用户
  │       ↓
  │      如果是冲突
  │       │   - 显示冲突解决界面
  │       │   - 用户选择保留哪个版本
  ↓
[前端] 更新同步状态
  │   - 更新任务列表的同步标识
  │   - 显示同步成功/失败提示
  ↓
结束
```

## 2.4 核心算法设计（基于当前实现）

### 2.4.1 数据统计分析算法

```javascript
/**
 * 分析表格数据的统计信息
 * @param {Array} data - 表格数据
 * @return {Object} - 统计结果
 */
function analyzeTableData(data) {
    if (!data || data.length === 0) {
        return {
            total: 0,
            unique: 0,
            duplicates: [],
            emptyCount: 0,
            completeness: 0
        };
    }
    
    // 统计重复数据
    const valueCount = {};
    const duplicates = [];
    
    data.forEach((item, index) => {
        // 检查姓名重复
        if (item.name) {
            if (valueCount[item.name]) {
                duplicates.push({
                    field: 'name',
                    value: item.name,
                    positions: [valueCount[item.name], index]
                });
            } else {
                valueCount[item.name] = index;
            }
        }
    });
    
    // 统计空值
    const emptyCount = data.reduce((count, item) => {
        return count + Object.values(item).filter(val => !val || val.trim() === '').length;
    }, 0);
    
    // 计算完整率
    const totalFields = data.length * Object.keys(data[0] || {}).length;
    const completeness = totalFields > 0 ? ((totalFields - emptyCount) / totalFields * 100).toFixed(1) : 0;
    
    return {
        total: data.length,
        unique: Object.keys(valueCount).length,
        duplicates: duplicates,
        emptyCount: emptyCount,
        completeness: completeness
    };
}
```

### 2.4.2 数据同步状态管理算法

```javascript
/**
 * 管理数据同步状态
 * @param {Array} tasks - 任务列表
 * @return {Object} - 同步状态统计
 */
function getSyncStatus(tasks) {
    const status = {
        synced: 0,
        unsynced: 0,
        total: tasks.length
    };
    
    tasks.forEach(task => {
        if (task.synced) {
            status.synced++;
        } else {
            status.unsynced++;
        }
    });
    
    return status;
}

/**
 * 批量同步数据
 * @param {Array} tasks - 需要同步的任务列表
 * @return {Promise} - 同步结果
 */
async function batchSyncTasks(tasks) {
    const results = {
        success: 0,
        failed: 0,
        errors: []
    };
    
    for (const task of tasks) {
        try {
            // 模拟同步请求
            await syncTaskToServer(task);
            task.synced = true;
            results.success++;
        } catch (error) {
            results.failed++;
            results.errors.push({
                taskId: task.id,
                error: error.message
            });
        }
    }
    
    return results;
}
```

### 2.4.3 数据校验算法

```javascript
/**
 * 校验村民信息数据的有效性
 * @param {Object} data - 村民数据
 * @return {Object} - 校验结果
 */
function validateVillagerData(data) {
    const errors = [];
    const warnings = [];
    
    // 姓名校验
    if (!data.name || data.name.trim() === '') {
        errors.push('姓名不能为空');
    } else if (data.name.length < 2 || data.name.length > 20) {
        errors.push('姓名长度应在2-20个字符之间');
    }
    
    // 手机号校验
    if (data.phone) {
        const phoneRegex = /^1[3-9]\d{9}$/;
        if (!phoneRegex.test(data.phone)) {
            errors.push('手机号格式不正确');
        }
    }
    
    // 身份证号校验
    if (data.idCard) {
        const idCardRegex = /^[1-9]\d{5}(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
        if (!idCardRegex.test(data.idCard)) {
            errors.push('身份证号格式不正确');
        }
    }
    
    // 地址校验
    if (data.address && data.address.length > 100) {
        warnings.push('地址长度超过建议值');
    }
    
    return {
        isValid: errors.length === 0,
        errors: errors,
        warnings: warnings
    };
}
```

### 2.4.4 增量同步算法

```javascript
/**
 * 增量同步算法：只同步变更的数据
 * @param {Number} lastSyncTime - 上次同步时间戳
 * @return {Object} - {toUpload: Array, toDownload: Array}
 */
async function incrementalSync(lastSyncTime) {
  // 1. 获取本地变更数据
  const localChanges = await db.tasks
    .where('update_time')
    .above(lastSyncTime)
    .and(task => task.sync_status === 'pending')
    .toArray();
  
  // 2. 请求服务器变更数据
  const serverChanges = await api.getChanges({
    since: lastSyncTime,
    client_id: getClientId()
  });
  
  // 3. 冲突检测
  const conflicts = [];
  const toUpload = [];
  const toDownload = [];
  
  // 3.1 构建本地变更映射
  const localMap = new Map();
  localChanges.forEach(task => {
    localMap.set(task.id, task);
  });
  
  // 3.2 检测冲突
  serverChanges.forEach(serverTask => {
    const localTask = localMap.get(serverTask.id);
    
    if (localTask) {
      // 同一任务在本地和服务器都有变更
      if (localTask.update_time > serverTask.update_time) {
        // 本地更新，上传
        toUpload.push(localTask);
      } else if (localTask.update_time < serverTask.update_time) {
        // 服务器更新，下载
        toDownload.push(serverTask);
      } else {
        // 时间戳相同，比较内容
        if (JSON.stringify(localTask.ocr_data) !== JSON.stringify(serverTask.ocr_data)) {
          // 内容不同，标记为冲突
          conflicts.push({
            task_id: localTask.id,
            local: localTask,
            server: serverTask
          });
        }
      }
      
      // 从本地映射中移除已处理的
      localMap.delete(serverTask.id);
    } else {
      // 服务器有新数据，下载
      toDownload.push(serverTask);
    }
  });
  
  // 3.3 剩余的本地变更都需要上传
  localMap.forEach(task => {
    toUpload.push(task);
  });
  
  return {
    toUpload: toUpload,
    toDownload: toDownload,
    conflicts: conflicts
  };
}

/**
 * 冲突解决策略
 */
function resolveConflict(conflict, strategy = 'server_wins') {
  switch(strategy) {
    case 'server_wins':
      // 服务器优先：使用服务器数据
      return conflict.server;
      
    case 'client_wins':
      // 客户端优先：使用本地数据
      return conflict.local;
      
    case 'latest_wins':
      // 最新优先：比较时间戳
      return conflict.local.update_time > conflict.server.update_time 
        ? conflict.local 
        : conflict.server;
      
    case 'manual':
      // 手动合并：返回null，由用户选择
      return null;
      
    default:
      return conflict.server;
  }
}
```

### 2.4.5 本地缓存管理算法

```javascript
/**
 * LRU缓存淘汰算法
 * 当本地存储空间不足时，淘汰最久未使用的数据
 */
class LRUCache {
  constructor(maxSize = 100 * 1024 * 1024) { // 默认100MB
    this.maxSize = maxSize;
    this.currentSize = 0;
    this.cache = new Map(); // key: task_id, value: {data, size, lastAccess}
  }
  
  async get(taskId) {
    if (!this.cache.has(taskId)) {
      // 从IndexedDB加载
      const task = await db.tasks.get(taskId);
      if (task) {
        this.put(taskId, task);
      }
      return task;
    }
    
    // 更新访问时间
    const item = this.cache.get(taskId);
    item.lastAccess = Date.now();
    this.cache.set(taskId, item);
    
    return item.data;
  }
  
  put(taskId, data) {
    const size = this.calculateSize(data);
    
    // 如果缓存已满，淘汰最久未使用的
    while (this.currentSize + size > this.maxSize && this.cache.size > 0) {
      this.evictLRU();
    }
    
    // 添加到缓存
    this.cache.set(taskId, {
      data: data,
      size: size,
      lastAccess: Date.now()
    });
    
    this.currentSize += size;
  }
  
  evictLRU() {
    // 找到最久未使用的项
    let lruKey = null;
    let lruTime = Infinity;
    
    for (const [key, value] of this.cache.entries()) {
      if (value.lastAccess < lruTime) {
        lruTime = value.lastAccess;
        lruKey = key;
      }
    }
    
    if (lruKey) {
      const item = this.cache.get(lruKey);
      this.currentSize -= item.size;
      this.cache.delete(lruKey);
      
      console.log(`[LRU] Evicted task ${lruKey}, freed ${item.size} bytes`);
    }
  }
  
  calculateSize(data) {
    // 估算对象大小（字节）
    return new Blob([JSON.stringify(data)]).size;
  }
  
  clear() {
    this.cache.clear();
    this.currentSize = 0;
  }
}
```

## 2.5 业务逻辑规则

### 2.5.1 任务状态机详细定义

```javascript
// 任务状态枚举
const TaskStatus = {
  CREATING: 'creating',        // 创建中
  RECOGNIZING: 'recognizing',  // 识别中
  PENDING: 'pending',          // 待确认
  CREATED: 'created',          // 已创建
  PROCESSING: 'processing',    // 进行中
  COMPLETED: 'completed',      // 已完成
  CANCELLED: 'cancelled',      // 已取消
  DELETED: 'deleted'           // 已删除
};

// 状态转换规则
const StateTransitions = {
  [TaskStatus.CREATING]: {
    allowed: [TaskStatus.RECOGNIZING, TaskStatus.CANCELLED],
    trigger: {
      [TaskStatus.RECOGNIZING]: 'onImageUploaded',
      [TaskStatus.CANCELLED]: 'onUserCancel'
    }
  },
  [TaskStatus.RECOGNIZING]: {
    allowed: [TaskStatus.PENDING, TaskStatus.CANCELLED],
    trigger: {
      [TaskStatus.PENDING]: 'onOCRCompleted',
      [TaskStatus.CANCELLED]: 'onOCRFailed'
    }
  },
  [TaskStatus.PENDING]: {
    allowed: [TaskStatus.CREATED, TaskStatus.CANCELLED],
    trigger: {
      [TaskStatus.CREATED]: 'onUserConfirm',
      [TaskStatus.CANCELLED]: 'onUserCancel'
    }
  },
  [TaskStatus.CREATED]: {
    allowed: [TaskStatus.PROCESSING, TaskStatus.DELETED],
    trigger: {
      [TaskStatus.PROCESSING]: 'onStartProcessing',
      [TaskStatus.DELETED]: 'onUserDelete'
    }
  },
  [TaskStatus.PROCESSING]: {
    allowed: [TaskStatus.COMPLETED, TaskStatus.CREATED, TaskStatus.DELETED],
    trigger: {
      [TaskStatus.COMPLETED]: 'onMarkComplete',
      [TaskStatus.CREATED]: 'onReopen',
      [TaskStatus.DELETED]: 'onUserDelete'
    }
  },
  [TaskStatus.COMPLETED]: {
    allowed: [TaskStatus.PROCESSING],
    trigger: {
      [TaskStatus.PROCESSING]: 'onReopen'
    }
  }
};

// 状态转换验证
function canTransition(currentStatus, targetStatus, user) {
  // 1. 检查状态转换是否允许
  const allowedStates = StateTransitions[currentStatus]?.allowed || [];
  if (!allowedStates.includes(targetStatus)) {
    return {
      allowed: false,
      reason: `不允许从 ${currentStatus} 转换到 ${targetStatus}`
    };
  }
  
  // 2. 检查用户权限
  if (targetStatus === TaskStatus.DELETED) {
    if (!user.hasPermission('task.delete')) {
      return {
        allowed: false,
        reason: '没有删除权限'
      };
    }
  }
  
  // 3. 检查业务规则
  if (targetStatus === TaskStatus.COMPLETED) {
    // 已完成的任务不能删除
    if (currentStatus === TaskStatus.COMPLETED) {
      return {
        allowed: false,
        reason: '已完成的任务不能删除'
      };
    }
  }
  
  return { allowed: true };
}
```

### 2.5.2 权限控制规则

```javascript
// 角色定义
const Roles = {
  ADMIN: 'admin',           // 管理员
  VILLAGE_LEADER: 'leader', // 村干部
  GROUP_LEADER: 'group',    // 小组长
  MEMBER: 'member'          // 普通成员
};

// 权限矩阵
const PermissionMatrix = {
  'task.create': [Roles.ADMIN, Roles.VILLAGE_LEADER, Roles.GROUP_LEADER],
  'task.view.all': [Roles.ADMIN, Roles.VILLAGE_LEADER],
  'task.view.own': [Roles.ADMIN, Roles.VILLAGE_LEADER, Roles.GROUP_LEADER, Roles.MEMBER],
  'task.edit.all': [Roles.ADMIN, Roles.VILLAGE_LEADER],
  'task.edit.own': [Roles.ADMIN, Roles.VILLAGE_LEADER, Roles.GROUP_LEADER],
  'task.delete.all': [Roles.ADMIN],
  'task.delete.own': [Roles.ADMIN, Roles.VILLAGE_LEADER, Roles.GROUP_LEADER]
};

// 权限检查函数
function checkPermission(user, permission, resource) {
  // 1. 检查角色权限
  const allowedRoles = PermissionMatrix[permission] || [];
  if (!allowedRoles.includes(user.role)) {
    return false;
  }
  
  // 2. 检查资源所有权
  if (permission.endsWith('.own')) {
    if (resource.creator_id !== user.id) {
      return false;
    }
  }
  
  // 3. 检查数据隔离
  if (user.role === Roles.GROUP_LEADER) {
    // 小组长只能访问本组数据
    if (resource.group_id !== user.group_id) {
      return false;
    }
  }
  
  if (user.role === Roles.VILLAGE_LEADER) {
    // 村干部只能访问本村数据
    if (resource.village_id !== user.village_id) {
      return false;
    }
  }
  
  return true;
}
```

### 2.5.3 数据验证规则

```javascript
// 任务数据验证规则
const TaskValidationRules = {
  title: {
    required: true,
    minLength: 2,
    maxLength: 50,
    pattern: /^[^<>'"&]*$/,  // 不允许特殊字符
    message: '标题长度2-50字符，不能包含特殊字符'
  },
  image_url: {
    required: true,
    pattern: /^https?:\/\/.+\.(jpg|jpeg|png|webp)$/i,
    message: '图片URL格式不正确'
  },
  ocr_data: {
    required: true,
    validator: (data) => {
      if (!data.rows || !Array.isArray(data.rows)) {
        return '表格数据格式错误';
      }
      if (data.rows.length === 0) {
        return '表格不能为空';
      }
      if (data.rows.length > 1000) {
        return '表格行数不能超过1000行';
      }
      return null;
    }
  }
};

// 验证函数
function validateTask(task) {
  const errors = [];
  
  for (const [field, rule] of Object.entries(TaskValidationRules)) {
    const value = task[field];
    
    // 必填检查
    if (rule.required && !value) {
      errors.push({
        field: field,
        message: `${field}不能为空`
      });
      continue;
    }
    
    // 长度检查
    if (rule.minLength && value.length < rule.minLength) {
      errors.push({
        field: field,
        message: rule.message || `${field}长度不能少于${rule.minLength}`
      });
    }
    
    if (rule.maxLength && value.length > rule.maxLength) {
      errors.push({
        field: field,
        message: rule.message || `${field}长度不能超过${rule.maxLength}`
      });
    }
    
    // 正则检查
    if (rule.pattern && !rule.pattern.test(value)) {
      errors.push({
        field: field,
        message: rule.message || `${field}格式不正确`
      });
    }
    
    // 自定义验证器
    if (rule.validator) {
      const error = rule.validator(value);
      if (error) {
        errors.push({
          field: field,
          message: error
        });
      }
    }
  }
  
  return {
    valid: errors.length === 0,
    errors: errors
  };
}
```

### 2.5.4 OCR识别质量控制

```javascript
// OCR质量评估
function assessOCRQuality(ocrResult) {
  const metrics = {
    averageConfidence: 0,
    lowConfidenceRatio: 0,
    emptyRatio: 0,
    structureScore: 0,
    overallScore: 0
  };
  
  // 1. 计算平均置信度
  let totalConfidence = 0;
  let totalCells = 0;
  let lowConfidenceCells = 0;
  let emptyCells = 0;
  
  ocrResult.rows.forEach(row => {
    row.cells.forEach(cell => {
      totalCells++;
      totalConfidence += cell.confidence;
      
      if (cell.confidence < 0.7) {
        lowConfidenceCells++;
      }
      
      if (!cell.content || cell.content.trim() === '') {
        emptyCells++;
      }
    });
  });
  
  metrics.averageConfidence = totalCells > 0 ? totalConfidence / totalCells : 0;
  metrics.lowConfidenceRatio = totalCells > 0 ? lowConfidenceCells / totalCells : 0;
  metrics.emptyRatio = totalCells > 0 ? emptyCells / totalCells : 0;
  
  // 2. 评估表格结构
  const colCounts = ocrResult.rows.map(row => row.cells.length);
  const maxCols = Math.max(...colCounts);
  const minCols = Math.min(...colCounts);
  const colVariance = maxCols - minCols;
  
  // 列数一致性得分（0-100）
  metrics.structureScore = Math.max(0, 100 - colVariance * 10);
  
  // 3. 计算综合得分
  metrics.overallScore = (
    metrics.averageConfidence * 40 +           // 置信度权重40%
    (1 - metrics.lowConfidenceRatio) * 30 +    // 低置信度比例权重30%
    (1 - metrics.emptyRatio) * 10 +            // 空单元格比例权重10%
    metrics.structureScore / 100 * 20          // 结构得分权重20%
  );
  
  // 4. 质量等级判定
  let qualityLevel = 'poor';
  if (metrics.overallScore >= 90) {
    qualityLevel = 'excellent';
  } else if (metrics.overallScore >= 75) {
    qualityLevel = 'good';
  } else if (metrics.overallScore >= 60) {
    qualityLevel = 'fair';
  }
  
  return {
    ...metrics,
    qualityLevel: qualityLevel,
    needManualReview: metrics.overallScore < 75 || metrics.lowConfidenceRatio > 0.3
  };
}
```

### 2.5.5 离线数据管理策略

```javascript
// 离线数据优先级
const OfflinePriority = {
  HIGH: 3,    // 高优先级：用户主动创建/修改的数据
  MEDIUM: 2,  // 中优先级：系统自动保存的数据
  LOW: 1      // 低优先级：缓存数据
};

// 离线存储策略
class OfflineStorageManager {
  constructor() {
    this.maxStorage = 50 * 1024 * 1024; // 50MB
    this.currentUsage = 0;
  }
  
  async saveOffline(task, priority = OfflinePriority.MEDIUM) {
    // 1. 检查存储空间
    await this.checkStorage();
    
    // 2. 保存到IndexedDB
    await db.tasks.put({
      ...task,
      offline_priority: priority,
      offline_saved_at: Date.now(),
      sync_status: 'pending'
    });
    
    // 3. 如果有图片，保存到本地文件系统
    if (task.image_url && task.image_url.startsWith('blob:')) {
      const localPath = await this.saveImageLocally(task.image_url, task.id);
      task.local_image_path = localPath;
    }
    
    // 4. 更新存储使用量
    await this.updateStorageUsage();
  }
  
  async checkStorage() {
    // 检查存储空间，如果不足则清理
    if (this.currentUsage > this.maxStorage * 0.9) {
      await this.cleanup();
    }
  }
  
  async cleanup() {
    // 清理策略：删除低优先级的已同步数据
    const tasksToDelete = await db.tasks
      .where('offline_priority')
      .equals(OfflinePriority.LOW)
      .and(task => task.sync_status === 'synced')
      .sortBy('offline_saved_at');
    
    // 删除最旧的20%数据
    const deleteCount = Math.ceil(tasksToDelete.length * 0.2);
    for (let i = 0; i < deleteCount; i++) {
      await db.tasks.delete(tasksToDelete[i].id);
      
      // 删除本地图片
      if (tasksToDelete[i].local_image_path) {
        await this.deleteLocalImage(tasksToDelete[i].local_image_path);
      }
    }
    
    await this.updateStorageUsage();
  }
  
  async updateStorageUsage() {
    const estimate = await navigator.storage.estimate();
    this.currentUsage = estimate.usage || 0;
  }
}
```

## 2.6 数据流向详细设计

### 2.6.1 任务创建数据流

```
[用户设备]
  │
  ├─ 1. 选择图片
  │   └─ wx.chooseImage() / wx.chooseMessageFile()
  │       └─ 返回临时文件路径 tempFilePath
  │
  ├─ 2. 图片预处理（客户端）
  │   ├─ 读取图片信息（宽高、大小、EXIF）
  │   ├─ 压缩图片（Canvas API）
  │   ├─ 旋转校正（根据EXIF Orientation）
  │   └─ 生成缩略图（用于列表展示）
  │
  ├─ 3. 上传图片
  │   └─ wx.uploadFile()
  │       ├─ URL: /api/v1/upload/image
  │       ├─ Method: POST
  │       ├─ Headers: {Authorization: Bearer <token>}
  │       └─ Body: FormData {file: <binary>}
  │
  ↓
[API网关]
  │
  ├─ 4. 请求验证
  │   ├─ Token验证（JWT）
  │   ├─ 文件类型验证（Content-Type）
  │   ├─ 文件大小验证（< 5MB）
  │   └─ 频率限制检查（100次/分钟）
  │
  ├─ 5. 路由转发
  │   └─ 转发到文件服务
  │
  ↓
[文件服务]
  │
  ├─ 6. 文件处理
  │   ├─ 生成唯一文件名（UUID + 时间戳）
  │   ├─ 病毒扫描（ClamAV）
  │   ├─ 图片安全检查（内容审核）
  │   └─ 上传到对象存储（COS/OSS）
  │       ├─ Bucket: village-tables
  │       ├─ Path: /{village_id}/{year}/{month}/{filename}
  │       └─ ACL: private
  │
  ├─ 7. 返回图片URL
  │   └─ Response: {image_url: "https://cdn.example.com/...", image_id: "..."}
  │
  ↓
[任务服务]
  │
  ├─ 8. 创建OCR任务
  │   ├─ 生成任务ID（Snowflake算法）
  │   ├─ 写入数据库
  │   │   └─ INSERT INTO tasks (id, image_url, status, creator_id, create_time)
  │   └─ 发送到消息队列
  │       ├─ Queue: ocr_tasks
  │       ├─ Message: {task_id, image_url, callback_url}
  │       └─ Priority: normal
  │
  ↓
[OCR服务]
  │
  ├─ 9. 消费OCR任务
  │   ├─ 从队列获取任务
  │   ├─ 下载图片
  │   ├─ 图片预处理
  │   │   ├─ 灰度化
  │   │   ├─ 二值化
  │   │   ├─ 去噪
  │   │   └─ 倾斜校正
  │   │
  │   ├─ 表格检测
  │   │   ├─ 边缘检测（Canny）
  │   │   ├─ 直线检测（Hough变换）
  │   │   ├─ 表格框定位
  │   │   └─ 单元格分割
  │   │
  │   ├─ 文字识别
  │   │   ├─ 调用OCR引擎（Tesseract/PaddleOCR）
  │   │   ├─ 批量识别单元格
  │   │   └─ 置信度评估
  │   │
  │   └─ 结果后处理
  │       ├─ 表格结构化
  │       ├─ 标题提取
  │       ├─ 数据清洗
  │       └─ 质量评估
  │
  ├─ 10. 回调任务服务
  │   └─ POST /api/v1/tasks/{task_id}/ocr_result
  │       └─ Body: {ocr_data, confidence, quality_score}
  │
  ↓
[任务服务]
  │
  ├─ 11. 保存OCR结果
  │   ├─ 更新任务状态：recognizing → pending
  │   ├─ 保存OCR数据（JSON格式）
  │   │   └─ UPDATE tasks SET ocr_data = ?, status = 'pending' WHERE id = ?
  │   └─ 更新Redis缓存
  │       └─ SET task:{task_id} {task_data} EX 3600
  │
  ├─ 12. 通知客户端
  │   └─ WebSocket推送 / 轮询返回
  │       └─ Message: {task_id, status: 'pending', ocr_data}
  │
  ↓
[用户设备]
  │
  ├─ 13. 接收OCR结果
  │   ├─ 解析OCR数据
  │   ├─ 提取标题
  │   ├─ 渲染表格预览
  │   └─ 显示编辑界面
  │
  ├─ 14. 用户确认创建
  │   └─ POST /api/v1/tasks
  │       └─ Body: {title, image_url, ocr_data, village_id}
  │
  ↓
[任务服务]
  │
  ├─ 15. 创建任务记录
  │   ├─ 数据验证
  │   ├─ 权限检查
  │   ├─ 写入数据库
  │   │   └─ INSERT INTO tasks (id, title, image_url, ocr_data, status, creator_id)
  │   ├─ 写入Redis缓存
  │   └─ 发送创建事件
  │       └─ Publish: task_created {task_id, creator_id, village_id}
  │
  ├─ 16. 返回任务详情
  │   └─ Response: {task_id, title, status, create_time, ...}
  │
  ↓
[用户设备]
  │
  ├─ 17. 保存到本地缓存
  │   ├─ IndexedDB.tasks.put(task)
  │   ├─ 更新任务列表
  │   └─ 标记同步状态：synced
  │
  └─ 18. 显示成功提示
      └─ Toast: "任务创建成功"
```

### 2.6.2 数据同步流程

```
[触发条件]
  - 网络从离线恢复
  - 定时器触发（每5分钟）
  - 用户手动刷新
  │
  ↓
[同步引擎]
  │
  ├─ 1. 检查网络状态
  │   └─ navigator.onLine
  │
  ├─ 2. 获取上次同步时间
  │   └─ localStorage.getItem('last_sync_time')
  │
  ├─ 3. 查询本地变更
  │   └─ SELECT * FROM tasks WHERE update_time > ? AND sync_status = 'pending'
  │
  ├─ 4. 请求服务器变更
  │   └─ GET /api/v1/sync/changes?since={timestamp}&client_id={id}
  │
  ↓
[同步服务]
  │
  ├─ 5. 查询服务器变更
  │   └─ SELECT * FROM tasks 
  │       WHERE update_time > ? 
  │       AND village_id = ?
  │       AND deleted = false
  │
  ├─ 6. 返回变更数据
  │   └─ Response: {
  │       changes: [{task_id, action, data, update_time}],
  │       server_time: timestamp
  │     }
  │
  ↓
[同步引擎]
  │
  ├─ 7. 冲突检测
  │   ├─ 构建本地变更Map
  │   ├─ 遍历服务器变更
  │   └─ 比较时间戳和内容
  │       ├─ 无冲突 → 直接应用
  │       └─ 有冲突 → 应用解决策略
  │
  ├─ 8. 应用服务器变更
  │   ├─ 下载变更（INSERT/UPDATE）
  │   │   └─ IndexedDB.tasks.put(serverTask)
  │   └─ 删除变更（DELETE）
  │       └─ IndexedDB.tasks.delete(task_id)
  │
  ├─ 9. 上传本地变更
  │   └─ POST /api/v1/sync/upload
  │       └─ Body: {changes: [localChanges]}
  │
  ↓
[同步服务]
  │
  ├─ 10. 验证变更
  │   ├─ 权限检查
  │   ├─ 数据验证
  │   └─ 冲突检测
  │
  ├─ 11. 应用变更到数据库
  │   └─ BEGIN TRANSACTION
  │       ├─ UPDATE tasks SET ... WHERE id = ?
  │       ├─ INSERT INTO task_history (task_id, action, data, user_id)
  │       └─ COMMIT
  │
  ├─ 12. 返回同步结果
  │   └─ Response: {
  │       success: true,
  │       synced_count: 10,
  │       failed: [],
  │       conflicts: []
  │     }
  │
  ↓
[同步引擎]
  │
  ├─ 13. 更新本地同步状态
  │   ├─ UPDATE tasks SET sync_status = 'synced' WHERE id IN (?)
  │   └─ localStorage.setItem('last_sync_time', server_time)
  │
  └─ 14. 通知UI更新
      └─ EventBus.emit('sync_completed', {count, conflicts})
```

## 2.7 性能优化策略

### 2.7.1 性能指标要求

| 指标 | 目标值 | 测量方法 |
|------|--------|---------|
| 首屏加载时间 | < 2秒 | Performance API |
| 图片上传时间 | < 5秒（2MB） | 上传开始到返回URL |
| OCR识别时间 | < 10秒 | 提交到返回结果 |
| 搜索响应时间 | < 300ms | 输入到显示结果 |
| 列表滚动帧率 | ≥ 60fps | requestAnimationFrame |
| 数据同步延迟 | < 3秒 | 本地修改到服务器确认 |
| 离线可用性 | 100% | 无网络时可查看缓存数据 |

### 2.7.2 优化策略

#### 前端优化

```javascript
// 1. 图片懒加载
class LazyImageLoader {
  constructor() {
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            this.loadImage(entry.target);
          }
        });
      },
      { rootMargin: '50px' }
    );
  }
  
  observe(img) {
    this.observer.observe(img);
  }
  
  loadImage(img) {
    const src = img.dataset.src;
    if (src) {
      img.src = src;
      img.removeAttribute('data-src');
      this.observer.unobserve(img);
    }
  }
}

// 2. 虚拟列表（长列表优化）
class VirtualList {
  constructor(container, itemHeight, renderItem) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.renderItem = renderItem;
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight) + 2;
    this.startIndex = 0;
  }
  
  render(data) {
    const scrollTop = this.container.scrollTop;
    this.startIndex = Math.floor(scrollTop / this.itemHeight);
    const endIndex = this.startIndex + this.visibleCount;
    
    const visibleData = data.slice(this.startIndex, endIndex);
    const html = visibleData.map((item, index) => 
      this.renderItem(item, this.startIndex + index)
    ).join('');
    
    this.container.innerHTML = html;
    this.container.style.paddingTop = `${this.startIndex * this.itemHeight}px`;
  }
}

// 3. 请求合并（防抖）
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// 4. 数据预加载
class DataPrefetcher {
  async prefetchTaskDetail(taskId) {
    // 预加载任务详情到缓存
    const task = await api.getTaskDetail(taskId);
    await cache.put(`task:${taskId}`, task);
  }
  
  async prefetchNextPage(currentPage) {
    // 预加载下一页数据
    const nextPage = currentPage + 1;
    const data = await api.getTaskList(nextPage, 20);
    await cache.put(`tasks:page:${nextPage}`, data);
  }
}
```

#### 后端优化

```javascript
// 1. 数据库查询优化
// 索引设计
CREATE INDEX idx_tasks_village_status ON tasks(village_id, status, create_time DESC);
CREATE INDEX idx_tasks_creator ON tasks(creator_id, create_time DESC);
CREATE INDEX idx_tasks_update_time ON tasks(update_time) WHERE sync_status = 'pending';

// 2. 缓存策略
class CacheManager {
  constructor(redis) {
    this.redis = redis;
    this.ttl = {
      task_detail: 3600,      // 1小时
      task_list: 300,         // 5分钟
      user_info: 7200,        // 2小时
      ocr_result: 86400       // 24小时
    };
  }
  
  async getTask(taskId) {
    // 1. 尝试从缓存获取
    const cached = await this.redis.get(`task:${taskId}`);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // 2. 从数据库查询
    const task = await db.tasks.findById(taskId);
    
    // 3. 写入缓存
    await this.redis.setex(
      `task:${taskId}`,
      this.ttl.task_detail,
      JSON.stringify(task)
    );
    
    return task;
  }
  
  async invalidateTask(taskId) {
    // 删除缓存
    await this.redis.del(`task:${taskId}`);
  }
}

// 3. 批量查询优化
async function batchGetTasks(taskIds) {
  // 使用IN查询代替多次单独查询
  const tasks = await db.tasks.findAll({
    where: {
      id: {
        [Op.in]: taskIds
      }
    }
  });
  
  return tasks;
}

// 4. 分页优化（游标分页）
async function getCursorPaginatedTasks(cursor, limit = 20) {
  const query = {
    limit: limit,
    order: [['create_time', 'DESC']]
  };
  
  if (cursor) {
    query.where = {
      create_time: {
        [Op.lt]: cursor
      }
    };
  }
  
  const tasks = await db.tasks.findAll(query);
  
  return {
    data: tasks,
    next_cursor: tasks.length > 0 ? tasks[tasks.length - 1].create_time : null,
    has_more: tasks.length === limit
  };
}
```

## 2.8 数据模型设计

### 2.8.1 任务表（tasks）

```sql
CREATE TABLE tasks (
  -- 主键
  id BIGINT PRIMARY KEY COMMENT '任务ID（Snowflake算法生成）',
  
  -- 基本信息
  title VARCHAR(100) NOT NULL COMMENT '任务标题',
  description TEXT COMMENT '任务描述',
  
  -- 关联信息
  village_id VARCHAR(50) NOT NULL COMMENT '所属村庄ID',
  group_id VARCHAR(50) COMMENT '所属小组ID',
  creator_id BIGINT NOT NULL COMMENT '创建人ID',
  creator_name VARCHAR(50) NOT NULL COMMENT '创建人姓名',
  
  -- 状态信息
  status VARCHAR(20) NOT NULL DEFAULT 'creating' COMMENT '任务状态：creating/recognizing/pending/created/processing/completed/cancelled/deleted',
  sync_status VARCHAR(20) NOT NULL DEFAULT 'pending' COMMENT '同步状态：pending/syncing/synced/failed',
  
  -- 图片信息
  image_url VARCHAR(500) NOT NULL COMMENT '原始图片URL',
  image_size INT COMMENT '图片大小（字节）',
  image_width INT COMMENT '图片宽度',
  image_height INT COMMENT '图片高度',
  thumbnail_url VARCHAR(500) COMMENT '缩略图URL',
  
  -- OCR信息
  ocr_data JSON COMMENT 'OCR识别结果（JSON格式）',
  ocr_confidence DECIMAL(5,4) COMMENT 'OCR平均置信度（0-1）',
  ocr_quality_score DECIMAL(5,2) COMMENT 'OCR质量得分（0-100）',
  need_manual_review BOOLEAN DEFAULT FALSE COMMENT '是否需要人工审核',
  
  -- 时间信息
  create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  complete_time DATETIME COMMENT '完成时间',
  delete_time DATETIME COMMENT '删除时间',
  
  -- 版本控制
  version INT NOT NULL DEFAULT 1 COMMENT '数据版本号（用于乐观锁）',
  
  -- 软删除标记
  deleted BOOLEAN NOT NULL DEFAULT FALSE COMMENT '是否已删除',
  
  -- 索引
  INDEX idx_village_status (village_id, status, create_time DESC),
  INDEX idx_creator (creator_id, create_time DESC),
  INDEX idx_sync_status (sync_status, update_time),
  INDEX idx_update_time (update_time) WHERE sync_status = 'pending'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='表格任务表';
```

### 2.8.2 任务历史表（task_history）

```sql
CREATE TABLE task_history (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  task_id BIGINT NOT NULL COMMENT '任务ID',
  action VARCHAR(20) NOT NULL COMMENT '操作类型：create/update/delete/status_change',
  
  -- 变更内容
  field_name VARCHAR(50) COMMENT '变更字段名',
  old_value TEXT COMMENT '变更前的值',
  new_value TEXT COMMENT '变更后的值',
  
  -- 操作人信息
  operator_id BIGINT NOT NULL COMMENT '操作人ID',
  operator_name VARCHAR(50) NOT NULL COMMENT '操作人姓名',
  operator_ip VARCHAR(50) COMMENT '操作人IP',
  
  -- 时间信息
  operate_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '操作时间',
  
  -- 索引
  INDEX idx_task_id (task_id, operate_time DESC),
  INDEX idx_operator (operator_id, operate_time DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务操作历史表';
```

### 2.8.3 OCR数据结构（JSON Schema）

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["table_title", "rows", "total_rows", "total_cols"],
  "properties": {
    "table_title": {
      "type": "string",
      "description": "表格标题",
      "minLength": 1,
      "maxLength": 100
    },
    "confidence": {
      "type": "number",
      "description": "整体置信度",
      "minimum": 0,
      "maximum": 1
    },
    "table_type": {
      "type": "string",
      "enum": ["regular", "handwritten", "mixed"],
      "description": "表格类型：regular-规则打印表格，handwritten-手写表格，mixed-混合"
    },
    "rows": {
      "type": "array",
      "description": "表格行数据",
      "items": {
        "type": "object",
        "required": ["row_index", "cells"],
        "properties": {
          "row_index": {
            "type": "integer",
            "description": "行索引（从0开始）",
            "minimum": 0
          },
          "is_header": {
            "type": "boolean",
            "description": "是否为表头行",
            "default": false
          },
          "cells": {
            "type": "array",
            "description": "单元格数据",
            "items": {
              "type": "object",
              "required": ["col_index", "content", "confidence"],
              "properties": {
                "col_index": {
                  "type": "integer",
                  "description": "列索引（从0开始）",
                  "minimum": 0
                },
                "content": {
                  "type": "string",
                  "description": "单元格内容"
                },
                "confidence": {
                  "type": "number",
                  "description": "识别置信度",
                  "minimum": 0,
                  "maximum": 1
                },
                "bbox": {
                  "type": "object",
                  "description": "单元格边界框坐标",
                  "properties": {
                    "x": {"type": "integer"},
                    "y": {"type": "integer"},
                    "width": {"type": "integer"},
                    "height": {"type": "integer"}
                  }
                },
                "need_review": {
                  "type": "boolean",
                  "description": "是否需要人工审核",
                  "default": false
                }
              }
            }
          }
        }
      }
    },
    "total_rows": {
      "type": "integer",
      "description": "总行数",
      "minimum": 1
    },
    "total_cols": {
      "type": "integer",
      "description": "总列数",
      "minimum": 1
    },
    "low_confidence_cells": {
      "type": "array",
      "description": "低置信度单元格列表",
      "items": {
        "type": "object",
        "properties": {
          "row": {"type": "integer"},
          "col": {"type": "integer"},
          "content": {"type": "string"},
          "confidence": {"type": "number"}
        }
      }
    },
    "metadata": {
      "type": "object",
      "description": "元数据",
      "properties": {
        "ocr_engine": {
          "type": "string",
          "description": "OCR引擎名称"
        },
        "ocr_version": {
          "type": "string",
          "description": "OCR引擎版本"
        },
        "process_time": {
          "type": "number",
          "description": "处理耗时（秒）"
        },
        "image_preprocessed": {
          "type": "boolean",
          "description": "图片是否经过预处理"
        }
      }
    }
  }
}
```

### 2.8.4 OCR数据示例

```json
{
  "table_title": "2023年第三季度人口统计表",
  "confidence": 0.92,
  "table_type": "regular",
  "rows": [
    {
      "row_index": 0,
      "is_header": true,
      "cells": [
        {
          "col_index": 0,
          "content": "姓名",
          "confidence": 0.98,
          "bbox": {"x": 10, "y": 10, "width": 80, "height": 30},
          "need_review": false
        },
        {
          "col_index": 1,
          "content": "年龄",
          "confidence": 0.97,
          "bbox": {"x": 100, "y": 10, "width": 60, "height": 30},
          "need_review": false
        },
        {
          "col_index": 2,
          "content": "性别",
          "confidence": 0.99,
          "bbox": {"x": 170, "y": 10, "width": 60, "height": 30},
          "need_review": false
        },
        {
          "col_index": 3,
          "content": "职业",
          "confidence": 0.96,
          "bbox": {"x": 240, "y": 10, "width": 100, "height": 30},
          "need_review": false
        }
      ]
    },
    {
      "row_index": 1,
      "is_header": false,
      "cells": [
        {
          "col_index": 0,
          "content": "张三",
          "confidence": 0.95,
          "bbox": {"x": 10, "y": 50, "width": 80, "height": 30},
          "need_review": false
        },
        {
          "col_index": 1,
          "content": "35",
          "confidence": 0.94,
          "bbox": {"x": 100, "y": 50, "width": 60, "height": 30},
          "need_review": false
        },
        {
          "col_index": 2,
          "content": "男",
          "confidence": 0.98,
          "bbox": {"x": 170, "y": 50, "width": 60, "height": 30},
          "need_review": false
        },
        {
          "col_index": 3,
          "content": "农民",
          "confidence": 0.93,
          "bbox": {"x": 240, "y": 50, "width": 100, "height": 30},
          "need_review": false
        }
      ]
    },
    {
      "row_index": 2,
      "is_header": false,
      "cells": [
        {
          "col_index": 0,
          "content": "李四",
          "confidence": 0.96,
          "bbox": {"x": 10, "y": 90, "width": 80, "height": 30},
          "need_review": false
        },
        {
          "col_index": 1,
          "content": "42",
          "confidence": 0.95,
          "bbox": {"x": 100, "y": 90, "width": 60, "height": 30},
          "need_review": false
        },
        {
          "col_index": 2,
          "content": "女",
          "confidence": 0.97,
          "bbox": {"x": 170, "y": 90, "width": 60, "height": 30},
          "need_review": false
        },
        {
          "col_index": 3,
          "content": "教师",
          "confidence": 0.94,
          "bbox": {"x": 240, "y": 90, "width": 100, "height": 30},
          "need_review": false
        }
      ]
    }
  ],
  "total_rows": 3,
  "total_cols": 4,
  "low_confidence_cells": [],
  "metadata": {
    "ocr_engine": "PaddleOCR",
    "ocr_version": "2.6.0",
    "process_time": 3.5,
    "image_preprocessed": true
  }
}
```

### 2.8.5 同步队列数据结构（Redis）

```javascript
// 同步队列键名规则
const SYNC_QUEUE_KEY = 'sync:queue:{village_id}';
const SYNC_LOCK_KEY = 'sync:lock:{task_id}';
const SYNC_STATUS_KEY = 'sync:status:{client_id}';

// 同步队列项结构
{
  task_id: "1234567890",
  action: "update",  // create/update/delete
  data: {
    // 任务完整数据
  },
  client_id: "client_abc123",
  timestamp: 1697788800000,
  retry_count: 0,
  priority: 2  // 1-低，2-中，3-高
}

// 同步状态结构
{
  client_id: "client_abc123",
  last_sync_time: 1697788800000,
  pending_count: 5,
  syncing: false,
  last_error: null
}
```

## 2.9 系统模块依赖关系

### 2.9.1 模块架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        前端层                                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ 个人中心 │  │ 任务管理 │  │ 搜索引擎 │  │ 数据同步 │   │
│  │  模块   │  │  模块   │  │  模块   │  │  模块   │   │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │
└───────┼─────────────┼─────────────┼─────────────┼─────────┘
        │             │             │             │
        └─────────────┴─────────────┴─────────────┘
                          │
                    ┌─────▼─────┐
                    │  API网关  │
                    └─────┬─────┘
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
   ┌────▼────┐      ┌────▼────┐      ┌────▼────┐
   │ 任务服务 │      │ OCR服务 │      │ 同步服务 │
   └────┬────┘      └────┬────┘      └────┬────┘
        │                 │                 │
        └─────────────────┴─────────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
   ┌────▼────┐      ┌────▼────┐      ┌────▼────┐
   │  MySQL  │      │  Redis  │      │   COS   │
   │ (主库)  │      │ (缓存)  │      │ (存储)  │
   └─────────┘      └─────────┘      └─────────┘
```

### 2.9.2 模块功能清单

#### P0级模块（核心功能，必须实现）

| 模块名称 | 功能描述 | 技术实现 | 依赖关系 |
|---------|---------|---------|---------|
| 任务管理模块 | 任务CRUD、状态管理 | Node.js + Express | MySQL, Redis |
| OCR识别模块 | 图片识别、表格解析 | Python + PaddleOCR | 对象存储, 消息队列 |
| 数据同步模块 | 增量同步、冲突解决 | WebSocket + IndexedDB | Redis, MySQL |
| 图片上传模块 | 图片压缩、上传、存储 | Multer + Sharp | 对象存储 |
| 权限验证模块 | JWT验证、权限检查 | Passport.js | Redis |

#### P1级模块（重要功能，优先实现）

| 模块名称 | 功能描述 | 技术实现 | 依赖关系 |
|---------|---------|---------|---------|
| 搜索引擎模块 | 全文检索、模糊匹配 | Elasticsearch | MySQL |
| 编辑模块 | 数据编辑、版本控制 | 前端组件 + 后端API | 任务管理模块 |
| 缓存管理模块 | LRU缓存、过期清理 | Redis + IndexedDB | - |
| 日志记录模块 | 操作日志、审计追踪 | Winston + MySQL | MySQL |

#### P2级模块（增强功能，后续实现）

| 模块名称 | 功能描述 | 技术实现 | 依赖关系 |
|---------|---------|---------|---------|
| 统计分析模块 | 数据统计、趋势分析 | ECharts + SQL | 任务管理模块 |
| 导出模块 | Excel导出、PDF导出 | ExcelJS + PDFKit | 任务管理模块 |
| 消息通知模块 | 任务通知、状态推送 | WebSocket + 微信模板消息 | 任务管理模块 |
| 数据备份模块 | 定时备份、恢复 | Cron + MySQL Dump | MySQL |

### 2.9.3 接口依赖关系

#### 任务管理模块对外提供的接口

```javascript
// RESTful API
POST   /api/v1/tasks              // 创建任务
GET    /api/v1/tasks              // 获取任务列表
GET    /api/v1/tasks/:id          // 获取任务详情
PUT    /api/v1/tasks/:id          // 更新任务
DELETE /api/v1/tasks/:id          // 删除任务
PATCH  /api/v1/tasks/:id/status   // 更新任务状态

// WebSocket事件
task.created                      // 任务创建事件
task.updated                      // 任务更新事件
task.deleted                      // 任务删除事件
task.status_changed               // 状态变更事件
```

#### 任务管理模块依赖的外部接口

```javascript
// OCR服务接口
POST /ocr/v1/recognize            // 提交识别任务
GET  /ocr/v1/tasks/:id            // 查询识别结果

// 对象存储接口
POST /storage/v1/upload           // 上传文件
GET  /storage/v1/files/:id        // 获取文件
DELETE /storage/v1/files/:id      // 删除文件

// 权限服务接口
POST /auth/v1/verify              // 验证token
GET  /auth/v1/permissions         // 获取用户权限

// 消息服务接口
POST /message/v1/send             // 发送消息
```

## 2.10 对其他业务模块的影响分析

### 2.10.1 村民档案模块

**影响类型：** 数据关联

**影响描述：**
- 表格中的人员信息可能需要关联到村民档案
- 需要提供村民ID匹配接口
- 需要支持批量导入到档案系统

**技术方案：**
```javascript
// 提供数据导出接口
GET /api/v1/tasks/:id/export?format=json&target=profile

// 返回格式
{
  "task_id": "123",
  "data": [
    {
      "name": "张三",
      "age": 35,
      "gender": "男",
      "suggested_profile_id": "profile_456",  // 智能匹配的档案ID
      "match_confidence": 0.95
    }
  ]
}
```

### 2.10.2 统计分析模块

**影响类型：** 数据源

**影响描述：**
- 表格数据作为统计分析的原始数据
- 需要提供结构化数据查询接口
- 需要支持数据聚合和筛选

**技术方案：**
```javascript
// 提供数据查询接口
GET /api/v1/tasks/data?village_id=xxx&date_from=xxx&date_to=xxx&fields=xxx

// 返回格式
{
  "total": 100,
  "data": [
    {
      "task_id": "123",
      "title": "人口统计表",
      "create_time": "2023-10-20",
      "table_data": [...]
    }
  ],
  "aggregation": {
    "total_rows": 1000,
    "total_tasks": 100,
    "avg_confidence": 0.92
  }
}
```

### 2.10.3 消息通知模块

**影响类型：** 事件触发

**影响描述：**
- 任务创建、完成、删除时需要发送通知
- 需要集成微信模板消息
- 需要支持消息订阅和取消订阅

**技术方案：**
```javascript
// 事件发布（使用EventEmitter）
eventBus.emit('task.created', {
  task_id: '123',
  creator_id: 'user_456',
  village_id: 'village_789',
  title: '人口统计表'
});

// 消息服务订阅事件
eventBus.on('task.created', async (event) => {
  // 查询订阅者
  const subscribers = await getSubscribers(event.village_id);
  
  // 发送通知
  for (const user of subscribers) {
    await sendWechatTemplateMessage({
      touser: user.openid,
      template_id: 'TASK_CREATED_TEMPLATE',
      data: {
        title: event.title,
        creator: event.creator_name,
        time: new Date().toLocaleString()
      }
    });
  }
});
```

### 2.10.4 权限管理系统

**影响类型：** 权限控制

**影响描述：**
- 需要对接统一权限管理系统
- 不同角色对任务的操作权限不同
- 需要支持数据隔离（村级、组级）

**技术方案：**
```javascript
// 权限中间件
async function checkPermission(req, res, next) {
  const user = req.user;
  const action = req.method + ' ' + req.path;
  const resource = await getResource(req.params.id);
  
  // 调用权限服务
  const hasPermission = await authService.checkPermission({
    user_id: user.id,
    role: user.role,
    action: action,
    resource: resource
  });
  
  if (!hasPermission) {
    return res.status(403).json({
      error: 'Permission denied'
    });
  }
  
  next();
}

// 数据隔离过滤
function applyDataIsolation(query, user) {
  if (user.role === 'group_leader') {
    query.where.group_id = user.group_id;
  } else if (user.role === 'village_leader') {
    query.where.village_id = user.village_id;
  }
  // admin角色不需要过滤
  
  return query;
}
```

### 2.10.5 影响评估矩阵

| 被影响模块 | 影响程度 | 改造工作量 | 风险等级 | 应对措施 |
|-----------|---------|-----------|---------|---------|
| 村民档案 | 中 | 2人天 | 低 | 提供标准数据导出接口 |
| 统计分析 | 高 | 5人天 | 中 | 设计通用数据查询接口，支持灵活筛选 |
| 消息通知 | 中 | 3人天 | 低 | 使用事件驱动架构，解耦模块依赖 |
| 权限系统 | 高 | 8人天 | 高 | 对接统一权限服务，实现细粒度权限控制 |
| 数据备份 | 低 | 1人天 | 低 | 纳入现有备份策略 |

---

# 三、数据埋点与监控需求

## 3.1 埋点架构设计

### 3.1.1 埋点SDK设计

```javascript
/**
 * 埋点SDK
 * 支持批量上报、离线缓存、自动重试
 */
class TrackingSDK {
  constructor(config) {
    this.config = {
      endpoint: config.endpoint || '/api/v1/tracking',
      batchSize: config.batchSize || 10,
      flushInterval: config.flushInterval || 5000,  // 5秒
      maxRetry: config.maxRetry || 3,
      ...config
    };
    
    this.queue = [];
    this.timer = null;
    this.init();
  }
  
  init() {
    // 启动定时上报
    this.timer = setInterval(() => {
      this.flush();
    }, this.config.flushInterval);
    
    // 页面卸载时上报
    window.addEventListener('beforeunload', () => {
      this.flush(true);  // 同步上报
    });
  }
  
  /**
   * 记录事件
   */
  track(eventName, properties = {}) {
    const event = {
      event_name: eventName,
      properties: {
        ...this.getCommonProperties(),
        ...properties
      },
      timestamp: Date.now(),
      event_id: this.generateEventId()
    };
    
    this.queue.push(event);
    
    // 达到批量大小，立即上报
    if (this.queue.length >= this.config.batchSize) {
      this.flush();
    }
  }
  
  /**
   * 上报数据
   */
  async flush(sync = false) {
    if (this.queue.length === 0) return;
    
    const events = this.queue.splice(0, this.config.batchSize);
    
    try {
      if (sync) {
        // 同步上报（使用sendBeacon）
        navigator.sendBeacon(
          this.config.endpoint,
          JSON.stringify({ events })
        );
      } else {
        // 异步上报
        await fetch(this.config.endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ events })
        });
      }
    } catch (error) {
      // 上报失败，重新加入队列
      this.queue.unshift(...events);
      console.error('Tracking failed:', error);
    }
  }
  
  getCommonProperties() {
    return {
      session_id: this.getSessionId(),
      user_id: this.getUserId(),
      device_info: this.getDeviceInfo(),
      page_url: window.location.href
    };
  }
  
  generateEventId() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
}
```

### 3.1.2 关键埋点事件

| 事件类型 | 事件名称 | 触发时机 | 关键参数 |
|---------|---------|---------|---------|
| 页面访问 | page_view | 页面加载完成 | page_name, page_path, referrer |
| 页面停留 | page_stay | 页面离开时 | page_name, stay_time |
| 任务创建 | task_create | 创建新任务 | task_type, image_count, create_method |
| 任务查看 | task_view | 查看任务详情 | task_id, task_status, view_duration |
| 任务编辑 | task_edit | 编辑任务数据 | task_id, edit_type, field_count |
| 任务删除 | task_delete | 删除任务 | task_id, delete_reason |
| 数据同步 | data_sync | 同步数据 | sync_type, sync_count, success_count |
| 错误上报 | error_report | 发生错误 | error_type, error_message, stack_trace |

## 3.2 监控指标设计

### 3.2.1 业务指标

| 指标名称 | 计算方式 | 监控频率 | 告警阈值 |
|---------|---------|---------|---------|
| 日活跃用户 | 当日有操作的用户数 | 每日 | < 前日80% |
| 任务创建量 | 当日创建的任务数 | 每小时 | < 同期50% |
| 任务完成率 | 完成任务数/总任务数 | 每日 | < 90% |
| 数据同步成功率 | 成功同步数/总同步数 | 实时 | < 95% |
| OCR识别准确率 | 准确识别数/总识别数 | 每日 | < 85% |

### 3.2.2 技术指标

| 指标名称 | 计算方式 | 监控频率 | 告警阈值 |
|---------|---------|---------|---------|
| API响应时间 | 95分位响应时间 | 每分钟 | > 2秒 |
| 系统可用性 | 成功请求数/总请求数 | 每分钟 | < 99.9% |
| 内存使用率 | 已用内存/总内存 | 每分钟 | > 80% |
| CPU使用率 | CPU使用百分比 | 每分钟 | > 90% |
| 磁盘使用率 | 已用磁盘/总磁盘 | 每小时 | > 85% |

---

# 四、验收标准

## 4.1 功能验收标准

### 4.1.1 核心功能验收

| 功能模块 | 验收标准 | 测试用例 | 验收标准 |
|---------|---------|---------|---------|
| 智能采集 | 支持图片上传、OCR识别、数据确认 | 上传10张不同格式的表格图片 | 识别准确率≥90% |
| 历史表格管理 | 支持任务列表展示、详情查看、状态管理 | 创建100个任务，验证列表性能 | 页面加载时间<2秒 |
| 数据同步 | 支持离线操作、自动同步、冲突解决 | 断网状态下操作，恢复网络后验证同步 | 同步成功率≥99% |
| 权限控制 | 支持角色权限、数据隔离 | 不同角色用户登录验证权限 | 权限控制准确率100% |

### 4.1.2 性能验收标准

| 性能指标 | 验收标准 | 测试环境 | 验收方法 |
|---------|---------|---------|---------|
| 首屏加载时间 | < 2秒 | 4G网络 | Lighthouse测试 |
| 图片上传时间 | < 5秒（2MB图片） | 10M带宽 | 实际测试 |
| OCR识别时间 | < 10秒 | 标准服务器 | 批量测试 |
| 并发用户数 | 支持1000并发 | 压力测试环境 | JMeter测试 |

## 4.2 技术验收标准

### 4.2.1 代码质量

| 指标 | 验收标准 | 检查工具 |
|------|---------|---------|
| 代码覆盖率 | ≥ 80% | Jest, Istanbul |
| 代码重复率 | ≤ 5% | SonarQube |
| 代码规范符合度 | 100% | ESLint, Prettier |
| 安全漏洞 | 0高危漏洞 | Snyk, OWASP |

### 4.2.2 安全要求

| 安全要求 | 验收标准 | 验证方法 |
|---------|---------|---------|
| 数据加密 | 敏感数据加密存储 | 数据库审计 |
| 权限控制 | 最小权限原则 | 渗透测试 |
| 输入验证 | 所有输入参数验证 | 安全扫描 |
| 日志审计 | 完整操作日志记录 | 日志分析 |

---

# 五、部署方案

## 5.1 环境规划

### 5.1.1 环境配置

| 环境 | 服务器配置 | 数据库 | 缓存 | 存储 |
|------|-----------|--------|------|------|
| 开发环境 | 2核4G | MySQL 8.0 | Redis 6.0 | 本地存储 |
| 测试环境 | 4核8G | MySQL 8.0 | Redis 6.0 | 对象存储 |
| 生产环境 | 8核16G | MySQL 8.0集群 | Redis集群 | 对象存储集群 |

### 5.1.2 部署架构

```
┌─────────────────────────────────────────────────────────┐
│                       负载均衡器                         │
└─────────────────────────┬───────────────────────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
   ┌────▼────┐      ┌────▼────┐      ┌────▼────┐
   │ Web服务器 │      │ Web服务器 │      │ Web服务器 │
   │ (Node.js) │      │ (Node.js) │      │ (Node.js) │
   └────┬────┘      └────┬────┘      └────┬────┘
        │                 │                 │
        └─────────────────┼─────────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
   ┌────▼────┐      ┌────▼────┐      ┌────▼────┐
   │ Redis集群 │     │ MySQL集群 │     │ 对象存储 │
   └─────────┘      └─────────┘      └─────────┘
```

## 5.2 部署流程

### 5.2.1 自动化部署

```yaml
# Jenkins Pipeline
trigger:
  - main

stages:
  - stage: Build
    steps:
      - sh: npm install
      - sh: npm run build
      - sh: npm run test
      
  - stage: Deploy to Test
    when:
      branch: main
    steps:
      - sh: docker build -t village-table-system:test .
      - sh: docker push village-table-system:test
      - sh: kubectl apply -f k8s/test-deployment.yaml
      
  - stage: Deploy to Production
    when:
      branch: release
    steps:
      - sh: docker build -t village-table-system:prod .
      - sh: docker push village-table-system:prod
      - sh: kubectl apply -f k8s/prod-deployment.yaml
```

---

# 六、风险控制

## 6.1 技术风险

| 风险类型 | 风险描述 | 影响程度 | 应对措施 |
|---------|---------|---------|---------|
| OCR识别准确率低 | 复杂表格识别效果不佳 | 高 | 提供人工审核机制，支持手动修正 |
| 数据同步冲突 | 多用户同时编辑冲突 | 中 | 实现冲突检测和解决策略 |
| 系统性能瓶颈 | 大量图片处理导致性能下降 | 中 | 图片压缩、异步处理、CDN加速 |
| 数据安全风险 | 敏感数据泄露 | 高 | 数据加密、权限控制、审计日志 |

## 6.2 业务风险

| 风险类型 | 风险描述 | 影响程度 | 应对措施 |
|---------|---------|---------|---------|
| 用户接受度低 | 农村用户不习惯使用 | 中 | 简化操作流程，提供培训支持 |
| 网络环境差 | 农村网络不稳定 | 高 | 支持离线操作，自动同步 |
| 数据质量差 | 录入数据不准确 | 中 | 数据校验、重复检测、人工审核 |

---

# 七、项目计划

## 7.1 开发阶段

| 阶段 | 时间周期 | 主要任务 | 交付物 |
|------|---------|---------|-------|
| 需求分析 | 1周 | 需求调研、原型设计 | 需求文档、原型 |
| 技术设计 | 2周 | 架构设计、技术选型 | 技术方案、数据库设计 |
| 开发实现 | 6周 | 前后端开发、单元测试 | 可运行系统 |
| 测试验收 | 2周 | 功能测试、性能测试 | 测试报告 |
| 部署上线 | 1周 | 生产部署、用户培训 | 上线系统 |

## 7.2 资源安排

| 角色 | 人数 | 职责 |
|------|-----|------|
| 项目经理 | 1 | 项目规划、进度控制 |
| 产品经理 | 1 | 需求分析、产品设计 |
| 前端开发 | 2 | 前端界面开发 |
| 后端开发 | 3 | 后端服务开发 |
| 测试工程师 | 1 | 测试用例设计、测试执行 |
| 运维工程师 | 1 | 环境部署、监控维护 |

---

# 八、总结

本产品需求文档详细描述了村庄表格管理系统的功能需求、技术方案、验收标准等内容。该系统通过智能OCR技术解决农村表格数据录入难题，具备以下核心价值：

1. **提升效率**：通过智能识别技术，大幅提升数据录入效率
2. **保障质量**：通过数据校验和人工审核，确保数据准确性
3. **支持离线**：完善的离线操作能力，适应农村网络环境
4. **易于使用**：简洁直观的操作界面，降低使用门槛

系统采用现代化的技术架构，具备良好的扩展性和维护性。通过分阶段实施和风险控制措施，确保项目顺利推进。

---

**文档版本：** v1.0  
**创建时间：** 2024年10月20日  
**最后更新：** 2024年10月20日  
**文档状态：** 已完成
    }
  }
  
  /**
   * 获取公共属性
   */
  getCommonProperties() {
    return {
      user_id: this.getUserId(),
      session_id: this.getSessionId(),
      platform: 'miniprogram',
      app_version: this.getAppVersion(),
      device_model: this.getDeviceModel(),
      os_version: this.getOSVersion(),
      network_type: this.getNetworkType(),
      page_url: this.getCurrentPage()
    };
  }
  
  generateEventId() {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// 初始化SDK
const tracker = new TrackingSDK({
  endpoint: 'https://api.example.com/tracking'
});
```

## 3.2 埋点事件定义

### 3.2.1 页面访问事件

```javascript
// 页面浏览事件
tracker.track('page_view', {
  page_name: 'task_list',
  page_title: '村庄表格',
  referrer: 'home',
  duration: 0  // 页面停留时长（离开时更新）
});

// 页面离开事件
tracker.track('page_leave', {
  page_name: 'task_list',
  duration: 45000  // 停留45秒
});
```

### 3.2.2 功能操作事件

```javascript
// 任务创建流程
tracker.track('task_create_start', {
  entry_point: 'workbench'  // 入口：workbench/quick_action
});

tracker.track('image_upload_start', {
  source: 'camera',  // camera/album/wechat
  image_size: 2048576  // 字节
});

tracker.track('image_upload_success', {
  source: 'camera',
  image_size: 2048576,
  upload_duration: 3500,  // 毫秒
  compressed_size: 1024000,
  compression_ratio: 0.5
});

tracker.track('ocr_recognition_start', {
  task_id: '123',
  image_url: 'https://...'
});

tracker.track('ocr_recognition_success', {
  task_id: '123',
  recognition_duration: 8500,
  confidence_score: 0.92,
  quality_score: 85,
  total_rows: 10,
  total_cols: 5,
  low_confidence_cells: 2
});

tracker.track('task_create_success', {
  task_id: '123',
  title_length: 15,
  total_duration: 12000,  // 从开始到完成的总耗时
  is_title_edited: true  // 用户是否修改了标题
});

// 任务编辑
tracker.track('task_edit_start', {
  task_id: '123',
  edit_type: 'ocr_data'  // ocr_data/title/status
});

tracker.track('task_edit_success', {
  task_id: '123',
  edit_type: 'ocr_data',
  changed_cells: 3,
  edit_duration: 120000
});

// 任务删除
tracker.track('task_delete', {
  task_id: '123',
  task_status: 'created',
  task_age: 86400000  // 任务创建后的时长（毫秒）
});

// 搜索
tracker.track('search', {
  keyword: '人口',
  result_count: 5,
  search_duration: 250,
  has_result: true
});
```

### 3.2.3 性能监控事件

```javascript
// 页面性能
tracker.track('page_performance', {
  page_name: 'task_list',
  load_time: 1500,
  dom_ready_time: 800,
  first_paint_time: 600,
  first_contentful_paint: 900,
  largest_contentful_paint: 1200
});

// API性能
tracker.track('api_performance', {
  api_name: 'GET /api/v1/tasks',
  duration: 350,
  status_code: 200,
  response_size: 15360,
  is_cached: false
});

// 图片加载性能
tracker.track('image_load_performance', {
  image_url: 'https://...',
  image_size: 1024000,
  load_duration: 2500,
  is_lazy_loaded: true
});
```

### 3.2.4 异常监控事件

```javascript
// 上传失败
tracker.track('upload_failed', {
  error_code: 'UPLOAD_TIMEOUT',
  error_message: 'Upload timeout after 30s',
  image_size: 5242880,
  network_type: '4g',
  retry_count: 2
});

// OCR识别失败
tracker.track('ocr_failed', {
  task_id: '123',
  error_code: 'OCR_LOW_QUALITY',
  error_message: 'Image quality too low',
  image_url: 'https://...',
  retry_count: 1
});

// 同步失败
tracker.track('sync_failed', {
  task_id: '123',
  error_code: 'SYNC_CONFLICT',
  error_message: 'Data conflict detected',
  retry_count: 3,
  conflict_type: 'version_mismatch'
});

// JavaScript错误
tracker.track('js_error', {
  error_message: error.message,
  error_stack: error.stack,
  page_url: window.location.href,
  user_agent: navigator.userAgent
});

// 网络错误
tracker.track('network_error', {
  api_url: '/api/v1/tasks',
  error_code: 'NETWORK_TIMEOUT',
  error_message: 'Request timeout',
  duration: 30000
});
```

## 3.3 监控指标体系

### 3.3.1 业务指标

```javascript
// 核心业务指标
const businessMetrics = {
  // 任务相关
  task_create_count: '任务创建数',
  task_create_success_rate: '任务创建成功率',
  task_edit_count: '任务编辑次数',
  task_delete_count: '任务删除数',
  
  // OCR相关
  ocr_recognition_count: 'OCR识别次数',
  ocr_success_rate: 'OCR识别成功率',
  ocr_avg_confidence: 'OCR平均置信度',
  ocr_avg_quality_score: 'OCR平均质量分',
  
  // 用户行为
  dau: '日活用户数',
  active_user_count: '活跃用户数',
  avg_session_duration: '平均会话时长',
  avg_task_per_user: '人均任务数',
  
  // 搜索相关
  search_count: '搜索次数',
  search_success_rate: '搜索成功率（有结果）',
  avg_search_result_count: '平均搜索结果数'
};
```

### 3.3.2 性能指标

```javascript
// 性能指标
const performanceMetrics = {
  // 页面性能
  avg_page_load_time: '平均页面加载时间',
  p95_page_load_time: 'P95页面加载时间',
  avg_fcp: '平均首次内容绘制时间',
  avg_lcp: '平均最大内容绘制时间',
  
  // API性能
  avg_api_response_time: '平均API响应时间',
  p95_api_response_time: 'P95 API响应时间',
  api_error_rate: 'API错误率',
  
  // 上传性能
  avg_upload_time: '平均上传时间',
  upload_success_rate: '上传成功率',
  
  // OCR性能
  avg_ocr_time: '平均OCR识别时间',
  p95_ocr_time: 'P95 OCR识别时间',
  
  // 同步性能
  avg_sync_time: '平均同步时间',
  sync_success_rate: '同步成功率'
};
```

### 3.3.3 异常指标

```javascript
// 异常指标
const errorMetrics = {
  // 错误率
  js_error_rate: 'JS错误率',
  api_error_rate: 'API错误率',
  upload_error_rate: '上传错误率',
  ocr_error_rate: 'OCR错误率',
  sync_error_rate: '同步错误率',
  
  // 错误分布
  error_by_type: '按类型分组的错误数',
  error_by_page: '按页面分组的错误数',
  error_by_device: '按设备分组的错误数'
};
```

## 3.4 监控告警规则

```javascript
// 告警规则配置
const alertRules = [
  {
    name: 'OCR识别成功率过低',
    metric: 'ocr_success_rate',
    condition: '< 0.85',
    duration: '5m',
    severity: 'critical',
    notification: ['email', 'sms', 'wechat']
  },
  {
    name: 'API响应时间过长',
    metric: 'p95_api_response_time',
    condition: '> 3000',  // 3秒
    duration: '5m',
    severity: 'warning',
    notification: ['email']
  },
  {
    name: '同步失败率过高',
    metric: 'sync_error_rate',
    condition: '> 0.1',  // 10%
    duration: '10m',
    severity: 'critical',
    notification: ['email', 'sms']
  },
  {
    name: 'JS错误率异常',
    metric: 'js_error_rate',
    condition: '> 0.05',  // 5%
    duration: '5m',
    severity: 'warning',
    notification: ['email']
  }
];
```

---

# 四、AI 服务开发需求

## 4.1 OCR表格识别服务

### 输入要求

- **图片格式**：JPG、PNG、WEBP
- **图片大小**：不超过5MB
- **图片分辨率**：建议1080p以上
- **表格类型**：支持规则表格、手写表格、打印表格

### 输出效果预期

#### 示例1：规则打印表格

**输入图片：**
```
┌──────┬──────┬──────┬──────┐
│ 姓名 │ 年龄 │ 性别 │ 职业 │
├──────┼──────┼──────┼──────┤
│ 张三 │  35  │  男  │ 农民 │
├──────┼──────┼──────┼──────┤
│ 李四 │  42  │  女  │ 教师 │
└──────┴──────┴──────┴──────┘
```

**输出JSON：**
```json
{
  "table_title": "人员信息表",
  "confidence": 0.96,
  "table_type": "regular",
  "rows": [
    {
      "row_index": 0,
      "is_header": true,
      "cells": [
        {"col_index": 0, "content": "姓名", "confidence": 0.98},
        {"col_index": 1, "content": "年龄", "confidence": 0.97},
        {"col_index": 2, "content": "性别", "confidence": 0.99},
        {"col_index": 3, "content": "职业", "confidence": 0.96}
      ]
    },
    {
      "row_index": 1,
      "is_header": false,
      "cells": [
        {"col_index": 0, "content": "张三", "confidence": 0.95},
        {"col_index": 1, "content": "35", "confidence": 0.94},
        {"col_index": 2, "content": "男", "confidence": 0.98},
        {"col_index": 3, "content": "农民", "confidence": 0.93}
      ]
    },
    {
      "row_index": 2,
      "is_header": false,
      "cells": [
        {"col_index": 0, "content": "李四", "confidence": 0.96},
        {"col_index": 1, "content": "42", "confidence": 0.95},
        {"col_index": 2, "content": "女", "confidence": 0.97},
        {"col_index": 3, "content": "教师", "confidence": 0.94}
      ]
    }
  ],
  "total_rows": 3,
  "total_cols": 4
}
```

#### 示例2：手写表格

**输入图片：** 手写填写的表格照片

**输出JSON：**
```json
{
  "table_title": "村民意见征集表",
  "confidence": 0.82,
  "table_type": "handwritten",
  "low_confidence_cells": [
    {"row": 1, "col": 2, "content": "同意", "confidence": 0.65, "need_review": true}
  ],
  "rows": [...],
  "total_rows": 5,
  "total_cols": 3
}
```

### 性能要求

- **识别准确率**：打印表格 ≥ 95%，手写表格 ≥ 85%
- **识别速度**：单张图片 < 10秒
- **并发处理**：支持100 QPS
- **可用性**：99.9%

### 特殊处理

1. **低置信度标记**
   - 置信度 < 0.7 的单元格标记为"需人工确认"
   - 前端用红色边框高亮显示

2. **表格标题提取**
   - 优先识别图片顶部文字作为标题
   - 如无明确标题，使用"表格_日期"格式自动生成
   - 标题长度限制：2-50字符

3. **表格结构修正**
   - 自动检测并修正倾斜表格
   - 识别合并单元格
   - 处理不规则表格边框

## 4.2 智能标题生成服务

### 输入要求

- OCR识别的表格内容
- 表格创建时间
- 表格类型（可选）

### 输出效果预期

**示例：**

**输入：**
```json
{
  "table_content": {
    "header": ["姓名", "年龄", "性别"],
    "rows": [...]
  },
  "create_time": "2023-10-20",
  "table_type": "population_statistics"
}
```

**输出：**
```json
{
  "suggested_title": "2023年10月人口统计表",
  "confidence": 0.92,
  "alternative_titles": [
    "人口信息登记表",
    "村民基本信息表"
  ]
}
```

---

# 五、周边接口影响说明

## 5.1 微信小程序接口

### 5.1.1 图片选择接口

- **接口名称**：`wx.chooseImage`
- **调用限制**：
  - 单次最多选择9张图片
  - 图片大小限制：10MB
  - 需要用户授权相册权限

### 5.1.2 相机接口

- **接口名称**：`wx.chooseMedia`
- **调用限制**：
  - 需要用户授权相机权限
  - 拍摄图片大小限制：10MB

### 5.1.3 文件选择接口

- **接口名称**：`wx.chooseMessageFile`
- **调用限制**：
  - 只能选择微信聊天中的文件
  - 文件大小限制：100MB
  - 需要用户授权

## 5.2 OCR服务接口

### 5.2.1 表格识别接口

- **接口地址**：`https://api.ocr.example.com/v1/table/recognize`
- **请求方式**：POST
- **限频策略**：
  - 单用户：100次/分钟
  - 单IP：1000次/分钟
- **超时时间**：30秒
- **重试策略**：失败后最多重试3次

### 5.2.2 费用说明

- 按调用次数计费
- 免费额度：1000次/月
- 超出后：0.01元/次

## 5.3 云存储接口

### 5.3.1 图片上传接口

- **接口地址**：`https://storage.example.com/v1/upload`
- **请求方式**：POST (multipart/form-data)
- **限频策略**：
  - 单用户：50次/分钟
  - 单文件大小：5MB
- **存储限制**：
  - 单用户总容量：10GB
  - 文件保存期限：永久

## 5.4 数据同步接口

### 5.4.1 任务同步接口

- **接口地址**：`https://api.example.com/v1/tasks/sync`
- **请求方式**：POST
- **限频策略**：
  - 单用户：30次/分钟
- **数据大小限制**：单次同步不超过1MB

---

# 六、其他需关注的信息

## 6.1 技术栈

- **前端**：微信小程序（原生开发）
- **UI框架**：Tailwind CSS
- **图标库**：Font Awesome 6.0
- **后端**：Node.js + Express
- **数据库**：MySQL 8.0 + Redis
- **OCR服务**：腾讯云OCR / 阿里云OCR
- **云存储**：腾讯云COS

## 6.2 兼容性要求

- **微信版本**：≥ 7.0.0
- **小程序基础库**：≥ 2.10.0
- **支持系统**：iOS 10+, Android 5.0+

## 6.3 安全要求

1. **数据加密**
   - 传输加密：HTTPS/TLS 1.2+
   - 存储加密：AES-256

2. **权限控制**
   - 基于角色的访问控制（RBAC）
   - 数据隔离：村级数据互不可见

3. **隐私保护**
   - 敏感信息脱敏
   - 符合《个人信息保护法》要求

## 6.4 测试要求

1. **功能测试**
   - 覆盖所有核心功能
   - 边界条件测试
   - 异常场景测试

2. **性能测试**
   - 并发用户：1000人
   - 响应时间：< 2秒
   - 成功率：> 99%

3. **兼容性测试**
   - 主流Android机型（华为、小米、OPPO、vivo）
   - iOS设备（iPhone 8及以上）
   - 不同屏幕尺寸适配

## 6.5 上线计划

### 第一阶段（MVP）
- 任务创建（照片上传）
- OCR识别
- 任务列表展示
- 任务详情查看

### 第二阶段
- 微信文件选择
- 识别结果编辑
- 搜索功能
- 数据同步

### 第三阶段
- 多人协作
- 权限管理
- 数据统计
- 导出功能

## 6.6 运营指标

- **日活用户（DAU）**：目标 500+
- **任务创建量**：目标 100+/天
- **OCR识别准确率**：目标 95%+
- **用户满意度**：目标 4.5/5.0

## 6.7 风险评估

| 风险项 | 风险等级 | 应对措施 |
|--------|---------|---------|
| OCR识别准确率不达标 | 高 | 提供人工修正功能，优化识别算法 |
| 网络不稳定导致同步失败 | 中 | 本地缓存 + 断点续传 |
| 用户操作复杂度高 | 中 | 简化流程，增加新手引导 |
| 并发量超出预期 | 低 | 弹性扩容，CDN加速 |

## 6.8 后续优化方向

1. **智能化**
   - 表格数据自动分类
   - 异常数据智能提醒
   - 历史数据趋势分析

2. **协作化**
   - 多人同时编辑
   - 评论和批注功能
   - 审批流程

3. **移动化**
   - 离线模式增强
   - 语音输入
   - 手写识别

---

**文档版本**：v1.0  
**编写日期**：2023-10-20  
**编写人**：产品团队  
**审核人**：待定  
**最后更新**：2023-10-20
